1. 优先级(权重)
    不同选择器之间有不同的优先级.
    权重顺序(由小到大):
    继承 < 通配符 < 标签选择器 < 类选择器 < ID选择器 < 行内样式 < !important
    实际上我们工作中用的比较多的就是 标签选择器 类选择器 和 ID选择器
    原理:
        a. 作用域越小的选择器,权重越高.
        b. 当一个属性自身没有,就用继承的;自身有,就用自身的.
        c. 逐一解释
            继承 < 通配符
            此处应用的原理时:当一个属性该元素未设置时,将继承祖先元素的该属性值;否则使用自身设置的该属性值.

            通配符 < 标签选择器
            通配符的作用域为全部元素;标签选择器的作用域为指定标签;因此通配符的作用域 > 标签选择器的作用域.
            所以:通配符选择器的权重 < 标签选择器

            标签选择器 < 类选择器
            对同一种标签来讲,标签选择器的作用域为全部该种标签的元素,而类选择器的作用域为该种标签中class="指定类名"的元素;
            因此标签选择器的作用域 > 类选择器作用域.
            所以:标签选择器的权重 < 类选择器的权重

            类选择器 < ID选择器
            类选择器可以选择多个元素,而ID选择器只能选择1个元素.因此:类选择器的作用域 > ID选择器.
            所以:类选择器的权重 < ID选择器的权重

            //TODO:这个现象背后是什么原理?
            ID选择器 < 行内样式
            这个现象上述原理均无法解释.

            //TODO:为什么会有!important这个东西出现呢?
            行内样式 < !important
            !important的作用就是让一条CSS语句无视权重规则,强行渲染该CSS语句.因此!important的权重最高.


    !important的注意点:
        !important只针对单条CSS语句生效,而非针对选择器生效.
        !important对继承的属性没有提升权重的作用.

2. 权重叠加
    权重是可以叠加的.
    a. CSS特殊性(Specificity).CSS的权重是有一套计算公式的.这套公式成为CSS特性.
    用4位数字来表示.0,0,0,0 其代表4个级别.值从左到右,左边的最大,一级大于一级,数位没有进制,级别之间不可超越.
    各种选择器的权重计算公式如下:
    继承:          0,0,0,0
    标签选择器:     0,0,0,1
    类/伪类选择器:  0,0,1,0
    ID选择器:      0,1,0,0
    行内样式:      1,0,0,0
    !important:   正无穷

    b. 注意:
        在多个选择器作用在同一个元素的同一个属性时,才会涉及到权重叠加的计算!道理很简单,只有冲突时才会考虑最终浏览器
        渲染哪个属性,考虑到渲染哪个属性才会计算权重.

        a:hover是2个选择器的叠加.标签选择器(a) + :hover(伪类选择器).所以它的权重是0,0,1,1

        权重相同的情况下层叠性是生效的!

        IE中有个BUG:在IE中,标签选择器的数量达到一定数量时,权重可超过一个类选择器.

3. 三大特性总结
    a. 继承性
    b. 层叠性
    c. 权重

4. 盒子模型感知
    网页布局的本质:将网页上的元素(文字/图片)都放到盒子里边,然后按照需求放到盒子中.

5. 边框
    注意:边框占据的是padding的周围.
    a. 边框的三大组成部分
        大小
        样式(实线/虚线/点线/双实线...)
        颜色

    b. 语法
        控制上下左右4条边框:
        border: 大小(单位px) 样式(solid:实线/dashed:虚线/dotted:点线/double:双实线) 颜色(具体颜色/16进制/rgb()/rgba())

    c. 控制单独边框
        语法:border-方位名词(除center):大小 样式 颜色

    d. 单独设置大小/样式/颜色
        边框大小:border-width
        边框样式:border-style
        边框颜色:border-color
        很少单独设置这几个属性.原因:和font-xxx不同,这3个属性必须都设置了,边框才能被显示,所以通常情况下都是使用border-left/right/...
        或border:...直接设置了.

    e. 对指定方向的边框的指定属性逐条设置
        border-方位名词-width/style/color:xxx

6. 细线表格
    问题:在没有设置外边距的前提条件下,表格中的2个td中间的边框重合了.也就是说计划应该是1px是边框,实际上变成了2px.
    table元素的一个属性:border-collapse: collapse;该属性用于合并重复的边框.
    注意:该属性针对的是table.而不是td.加在td上是没有作用的.

7. 边框圆角(CSS3)
    圆角本质上和边框没啥关系.没有边框的div也可以设置圆角.只是以border开头,所以这个知识点归在border中了.
    语法:border-radius: 5px;
    取值:px/%(百分比的参照值为当前盒子完整的宽高.工作中用的最多的是50%.)
    注意:
        a. 像素值越大,圆的越厉害.
        b. 边框圆角并需要依赖于边框才可设置.
        c. 取值如果是百分比,则参照值为当前盒子完整的宽高. //TODO:如果当前盒子的宽高是不同的,取值规则如何?
        d. 取值时,如果填写了2个参数(e.g:border-radius: 10px 150px;),则参数1控制的是左上角和右下角;参数2控制的是右上角和左下角.
        e. 取值时,如果填写了3个参数(e.g:border-radius: 10px 50px 150px;),则参数1控制的是左上角;参数2控制的是右上角和左下角;
           参数3控制的是右下角.
        f. 取值时,如果填写了4个参数(e.g:border-radius: 10px 20px 30px 40px;),则从参数1到参数4,从左上角开始顺时针控制容器的4个角.

    Tips:
        a. 胶囊形
            使用border-radius讲一个长方形修改为胶囊形:设置border-radius的值为height的一半即可.
            (本质上就是将长方形容器的高度"弯"没了,就是胶囊形了.)

        b. 椭圆形
            对于一个长方形容器而言,设置border-radius的值为50%即可.

8. padding语法
    a. 取值
        1个值: 上下左右都有内填充 e.g:padding: 10px;
        2个值: 参数1为上下2个方向的内边距 参数2为左右2个方向的内边距 e.g:padding: 10px 50px;
        3个值: 参数1为上方向边距 参数2为左右2个方向的内边距 参数3为下方向内边距. e.g:padding: 10px 50px 100px;
        4个值: 参数1位上方向边距 参数2为右方向边距 参数3为下方向边距 参数4为左方向边距 即:从上方向开始 顺时针方向取参数 e.g:padding: 10px 50px 100px 200px;

    b. 单一方向上的padding取值
        padding-方位名词(除center):

9. padding的注意事项
    a. 行内元素里不要写上下的padding.但可以写左右的padding.   //TODO:为什么?
        原因:浏览器确实渲染了行内元素的上下padding效果,但不承认上下padding占据了位置.
            但是左右的padding距离,浏览器是承认的.
            那么:如果要调整一个行内元素在垂直方向上的位置该怎么做呢?
            解决方案:行高.

    b. 宽度可以被子代元素继承.但padding不会.

10. margin基本语法
    margin:外边距.即盒子与盒子之间的距离.
    a. 取值
        和padding基本一样.
        1个值:四周
        2个值:上下 左右
        3个值:上 左右 下
        4个值:上 右 下 左
        注意:取值时只有0可以不写单位.其他值都必须写单位(例如px).

    b. 单一方向上的margin取值
        margin-方位名词

    c. 功能
        控制盒子的位置,但并不会影响盒子的大小(特殊情况除外).如果右侧不设置外边距的话,由于盒子是块元素,所以自己要独占一行.
        因此看起来右侧外边距是占满整个body的.但那是视觉效果.不是margin的宽度.

    d. margin的注意事项
        行内元素不要给margin.
        原则:行内元素的左右内外边距可以设置,上下的不要动.

    e. margin的特殊值
        auto:自动取值.只对水平方向的margin有作用.使得margin-left的值和margin-right的值相等.
        与text-align:center;的区别:text-align:center;的作用不是让盒子水平居中,而是让盒子中的
        内容(文本/行内块)垂直居中.而margin:0 auto;是将整个盒子自身水平居中.不会对其中的文本生效.

        注意:
            1. margin:0 auto;使盒子水平居中是有前提条件的:应用该属性的元素必须为块级元素.不能是行内元素;
               且margin:0 auto;的盒子必须有固定的宽度,否则看不出来居中了.


11. 清除内外边距
    浏览器给body h1-6 ul li p标签等标签都设置了默认的外边距.甚至li还有默认的padding.而且不同浏览器设置的margin值是不同的.
    所以这种让浏览器自定义的东西应该清除掉.
    因此应该利用通配符选择器清除掉浏览器和常用标签的默认内外边距.

12. 外边距的BUG
    a. BUG1
        当上下相邻的2个块元素相遇时,如果上面的元素有下外边距(margin-bottom),下面的元素有上外边距(margin-top),则他们之间的垂直间距
        不是margin-bottom + margin-top,而是max(margin-bottom, margin-top).这种现象被称为相邻块元素垂直外边距的合并(也称外边距塌陷).
    解决方案
        只给1个盒子加margin-bottom或margin-top,设置该属性的值为需求中的距离.不要两个都加.

    b. BUG2
        对于2个嵌套关系的块元素,如果父元素没有上内边距(padding-top)和上边框(border-top),则父元素的上外边距(margin-top)会与
        子元素的上外边距(margin-top)发生合并,合并后的外边距(margin-top?)为二者中较大这,即使父元素的上外边距为0(margin-top),也会发生合并.
    解决方案:
        ①:不要给子元素设置margin-top,而是给父盒子设置padding-top.(个人认为这个解决方法并不好,因为设置了一个padding就等于在页面上
        平白无故地多了一部分内容.而且本质上我们要的效果是子元素往下走,而不是父元素的顶部往上涨.)
        ②:给父元素定义1px的上边框或上内边距.(至少这个解决方案比上边的那个靠谱.)
        ③:给父容器添加overflow:hidden

    结论:padding的稳定性比margin强.

13. padding强化
    a.
        当容器内部直接就是文本内容时,需要控制文本内容的距盒子的边距时,除了使用padding外,
        还可以使用text-indent.而且使用text-indent的效果比padding要好,因为使用padding后,
        还要重新计算容器的width大小,而使用text-indent,其目标物为文本,不涉及到容器的属性变化.

    b.
        设:父元素与子元素均为块级元素;当子元素不设置宽度时,对子元素设置padding,则此时浏览器在渲染
        时会默认减掉左右padding.